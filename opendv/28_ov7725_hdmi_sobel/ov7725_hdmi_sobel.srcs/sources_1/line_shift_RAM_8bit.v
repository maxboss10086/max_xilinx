//****************************************Copyright (c)***********************************//
//技术支持：www.openedv.com
//淘宝店铺：http://openedv.taobao.com 
//关注微信公众平台微信号："正点原子"，免费获取FPGA & STM32资料。
//版权所有，盗版必究。
//Copyright(C) 正点原子 2018-2028
//All rights reserved
//----------------------------------------------------------------------------------------
// File name:           line_shift_RAM_8bit
// Last modified Date:  2019/7/19 10:55:56
// Last Version:        V1.0
// Descriptions:        line_shift_RAM_8bit
//----------------------------------------------------------------------------------------
// Created by:          正点原子
// Created date:        2019/7/19 10:55:56
// Version:             V1.0
// Descriptions:        The original version
//		两个伪双端口RAM用于存储 旧两行的数据。
//		在新一行的数据到来时，在延迟打拍的时序下，
//		先将RAM中的旧一行数据读出，再将新一行数据写入到RAM。
//----------------------------------------------------------------------------------------
//****************************************************************************************//

module line_shift_RAM_8bit(
	input clock,

	input          clken,
	input          per_frame_href,
	
	input   [7:0]  shiftin,  //当前行的数据
	output  [7:0]  taps0x,   //前一行的数据
	output  [7:0]  taps1x    //前前一行的数据
);

//wire define
wire [7:0]  taps1x;
wire [7:0]  taps0x;

//reg define
reg  [3:0]  clken_dly;
reg  [9:0]  ram_rd_addr;
reg  [9:0]  ram_rd_addr_d0;
reg  [9:0]  ram_rd_addr_d1;
reg  [9:0]  ram_rd_addr_d2;
reg  [9:0]  ram_rd_addr_d3;
reg  [7:0]  shiftin_d0;
reg  [7:0]  shiftin_d1;
reg  [7:0]  taps0x_d0;
reg  [7:0]  taps0x_d1;
reg  [7:0]  taps0x_d2;

//*****************************************************
//**                    main code
//*****************************************************

always@(posedge clock) begin
	clken_dly <= { clken_dly[2:0] , clken };
end

//在数据到来时，RAM的读地址累加
always@(posedge clock)begin
	if(per_frame_href)
		if(clken)
			ram_rd_addr <= ram_rd_addr + 1 ;
		else
			ram_rd_addr <= ram_rd_addr ;
	else
		ram_rd_addr <= 0 ;
end

//将RAM地址延迟4拍
always@(posedge clock ) begin
	ram_rd_addr_d0 <= ram_rd_addr;
	ram_rd_addr_d1 <= ram_rd_addr_d0;
	ram_rd_addr_d2 <= ram_rd_addr_d1;
	ram_rd_addr_d3 <= ram_rd_addr_d2;
end

//输入数据延迟2拍送入RAM
always@(posedge clock)begin
	shiftin_d0 <= shiftin;
	shiftin_d1 <= shiftin_d0;
end

blk_mem_gen_0  u_ram_1024x8_1(
  .clka   (clock),
  .wea    (clken_dly[2]),
  .addra  (ram_rd_addr_d2),
  .dina   (shiftin_d1),
  
  .clkb   (clock),
  .addrb  (ram_rd_addr_d0),
  .doutb  (taps0x)
);

//将第一个RAM的输出延迟3拍送入RAM
always@(posedge clock)begin
	taps0x_d0  <= taps0x;
	taps0x_d1  <= taps0x_d0;
	taps0x_d2  <= taps0x_d1;
end

blk_mem_gen_0  u_ram_1024x8_2(
	.clka   (clock),
	.wea    (clken_dly[3]),
	.addra  (ram_rd_addr_d3),
	.dina   (taps0x_d2),

	.clkb   (clock),
	.addrb  (ram_rd_addr_d0),
	.doutb  (taps1x)
);

endmodule
